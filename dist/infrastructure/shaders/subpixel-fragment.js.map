{"version":3,"file":"subpixel-fragment.js","sources":["../../../src/infrastructure/shaders/subpixel-fragment.ts"],"sourcesContent":["/**\n * Fragment shader for CRT subpixel effect\n * Uses external textures for both images (via VideoFrame) and camera\n */\nimport tgpu, { type TgpuSampler, type TgpuUniform } from \"typegpu\";\nimport * as d from \"typegpu/data\";\nimport * as std from \"typegpu/std\";\n\n/**\n * Bind group layout for the subpixel shader (external texture)\n */\nexport const bindGroupLayout = tgpu.bindGroupLayout({\n  externalTexture: { externalTexture: d.textureExternal() },\n});\n\n/**\n * Create the subpixel fragment shader\n *\n * Implements a 3x3 RGB stripe pattern:\n * - Each input pixel becomes a 3x3 block\n * - When orientation is 0 (columns): vertical RGB stripes\n *   - Columns 0, 3, 6... show only red channel\n *   - Columns 1, 4, 7... show only green channel\n *   - Columns 2, 5, 8... show only blue channel\n * - When orientation is 1 (rows): horizontal RGB stripes\n *   - Rows 0, 3, 6... show only red channel\n *   - Rows 1, 4, 7... show only green channel\n *   - Rows 2, 5, 8... show only blue channel\n */\nexport function createSubpixelFragment(\n  sampler: TgpuSampler,\n  outputDimensions: TgpuUniform<d.Vec2u>,\n  inputDimensions: TgpuUniform<d.Vec2u>,\n  orientation: TgpuUniform<d.U32>,\n  pixelDensity: TgpuUniform<d.U32>,\n  interlaced: TgpuUniform<d.U32>,\n  field: TgpuUniform<d.U32>,\n) {\n  return tgpu[\"~unstable\"].fragmentFn({\n    in: { uv: d.vec2f },\n    out: d.vec4f,\n  })((input) => {\n    \"use gpu\";\n    // Get output pixel coordinate from UV and output dimensions\n    const outputDims = outputDimensions.$;\n    const pixelCoord = input.uv.mul(d.vec2f(outputDims.x, outputDims.y));\n\n    // Calculate which position in the 3x3 block (0, 1, or 2)\n    // Use X for columns (vertical stripes), Y for rows (horizontal stripes)\n    const blockX = d.u32(pixelCoord.x) % 3;\n    const blockY = d.u32(pixelCoord.y) % 3;\n    const blockPos = std.select(blockX, blockY, orientation.$ === 1);\n\n    // Calculate which logical pixel we're in (output / 3)\n    const logicalPixelCoord = pixelCoord.div(3);\n\n    // Each logical pixel represents 'density' input pixels\n    // Convert logical pixel to input pixel space and sample from center of the group\n    const density = d.f32(pixelDensity.$);\n    const logicalPixelIndex = std.floor(logicalPixelCoord);\n\n    // Each logical pixel represents a group of 'density' input pixels\n    // Sample from the center of that group: logicalPixelIndex * density + density / 2\n    const groupedPixel = logicalPixelIndex.mul(density).add(density / 2.0);\n\n    // Use actual input texture dimensions\n    const inputDims = d.vec2f(inputDimensions.$.x, inputDimensions.$.y);\n    const inputUV = groupedPixel.div(inputDims);\n\n    // Sample the external texture using textureSampleBaseClampToEdge\n    const inputColor = std.textureSampleBaseClampToEdge(\n      bindGroupLayout.$.externalTexture,\n      sampler.$,\n      inputUV,\n    );\n\n    // Check interlacing: if enabled, skip pixel blocks that don't match the selected field\n    // Each logical pixel is 3x3, so we alternate between 3 rows rendered and 3 rows skipped\n    const isInterlaced = interlaced.$ === 1;\n    if (isInterlaced) {\n      const outputY = d.u32(pixelCoord.y);\n      // Calculate which logical pixel row we're in (each pixel is 3 rows tall)\n      const logicalPixelRow = outputY / 3;\n      const logicalPixelRowIndex = d.u32(logicalPixelRow);\n      // Determine which field this logical pixel row belongs to (0 or 1)\n      const pixelRowField = logicalPixelRowIndex % 2;\n      const selectedField = d.u32(field.$); // 0 for even field, 1 for odd field\n\n      // Skip rendering if pixel row field doesn't match selected field\n      // Odd field (1): render rows 0-2, 6-8, 12-14... (pixelRowField === 0)\n      // Even field (0): render rows 3-5, 9-11, 15-17... (pixelRowField === 1)\n      const shouldSkip = pixelRowField !== selectedField;\n      if (shouldSkip) {\n        // Return transparent/black for skipped pixel rows\n        return d.vec4f(0.0, 0.0, 0.0, 1.0);\n      }\n    }\n\n    // Apply subpixel pattern based on block position\n    let outputColor = inputColor;\n    if (blockPos === 0) {\n      // Red stripe: use red channel only\n      outputColor = d.vec4f(inputColor.x, 0.0, 0.0, inputColor.w);\n    } else if (blockPos === 1) {\n      // Green stripe: use green channel only\n      outputColor = d.vec4f(0.0, inputColor.y, 0.0, inputColor.w);\n    } else {\n      // Blue stripe: use blue channel only\n      outputColor = d.vec4f(0.0, 0.0, inputColor.z, inputColor.w);\n    }\n\n    return outputColor;\n  });\n}\n"],"names":["bindGroupLayout","a","tgpu","d","createSubpixelFragment","sampler","outputDimensions","inputDimensions","orientation","pixelDensity","interlaced","field","$","input","outputDims","pixelCoord","blockX","blockY","blockPos","std","logicalPixelCoord","density","groupedPixel","inputDims","inputUV","inputColor","logicalPixelRow","pixelRowField","selectedField","outputColor"],"mappings":";;;AAWO,MAAMA,KAAA,WAAA,yBAAA,CAAAC,MAAAA,IAAkBC,EAAK,gBAAgB;AAAA,EAClD,iBAAiB,EAAE,iBAAiBC,EAAE,kBAAgB;AACxD,CAAC,GAAA,iBAAA;AAgBM,SAASC,EACdC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACA;AACA,SAAOT,EAAK,WAAW,EAAE,WAAW;AAAA,IAClC,IAAI,EAAE,IAAIC,EAAE,MAAA;AAAA,IACZ,KAAKA,EAAE;AAAA,EAAA,CACR,GAAA,CAAAS,OAAA,WAAA,qBAAA,oBAAA,QAAA,GAAA,IAAAA,EAAA,KAAE,CAACC,MAAU;AACZ;AAEA,UAAMC,IAAaR,EAAiB,GAC9BS,IAAaF,EAAM,GAAG,IAAIV,EAAE,MAAMW,EAAW,GAAGA,EAAW,CAAC,CAAC,GAI7DE,IAASb,EAAE,IAAIY,EAAW,CAAC,IAAI,GAC/BE,IAASd,EAAE,IAAIY,EAAW,CAAC,IAAI,GAC/BG,IAAWC,EAAI,OAAOH,GAAQC,GAAQT,EAAY,MAAM,CAAC,GAGzDY,IAAoBL,EAAW,IAAI,CAAC,GAIpCM,IAAUlB,EAAE,IAAIM,EAAa,CAAC,GAK9Ba,IAJoBH,EAAI,MAAMC,CAAiB,EAId,IAAIC,CAAO,EAAE,IAAIA,IAAU,CAAG,GAG/DE,IAAYpB,EAAE,MAAMI,EAAgB,EAAE,GAAGA,EAAgB,EAAE,CAAC,GAC5DiB,IAAUF,EAAa,IAAIC,CAAS,GAGpCE,IAAaN,EAAI;AAAA,MACrBnB,EAAgB,EAAE;AAAA,MAClBK,EAAQ;AAAA,MACRmB;AAAA,IAAA;AAMF,QADqBd,EAAW,MAAM,GACpB;AAGhB,YAAMgB,IAFUvB,EAAE,IAAIY,EAAW,CAAC,IAEA,GAG5BY,IAFuBxB,EAAE,IAAIuB,CAAe,IAEL,GACvCE,IAAgBzB,EAAE,IAAIQ,EAAM,CAAC;AAMnC,UADmBgB,MAAkBC;AAGnC,eAAOzB,EAAE,MAAM,GAAK,GAAK,GAAK,CAAG;AAAA,IAErC;AAGA,QAAI0B,IAAcJ;AAClB,WAAIP,MAAa,IAEfW,IAAc1B,EAAE,MAAMsB,EAAW,GAAG,GAAK,GAAKA,EAAW,CAAC,IACjDP,MAAa,IAEtBW,IAAc1B,EAAE,MAAM,GAAKsB,EAAW,GAAG,GAAKA,EAAW,CAAC,IAG1DI,IAAc1B,EAAE,MAAM,GAAK,GAAKsB,EAAW,GAAGA,EAAW,CAAC,GAGrDI;AAAA,EACT,IAAA;AAAA;;;;;;;AACF;"}