{"version":3,"file":"CameraManager.js","sources":["../../src/infrastructure/CameraManager.ts"],"sourcesContent":["/**\n * Camera Manager\n * Handles camera stream lifecycle and video element management\n */\nimport { type CameraOptions, DEFAULT_CAMERA_OPTIONS } from \"../core/types.js\";\nimport { Dimensions } from \"../core/value-objects/Dimensions.js\";\nimport type { ICameraManager } from \"../core/ports/ICameraManager.js\";\n\n/**\n * Camera stream information\n */\nexport interface CameraStream {\n  /** The video element containing the camera stream */\n  video: HTMLVideoElement;\n  /** The underlying media stream */\n  stream: MediaStream;\n}\n\n/**\n * Manages camera access and video stream lifecycle\n */\nexport class CameraManager implements ICameraManager {\n  private cameraStream: CameraStream | null = null;\n\n  /**\n   * Check if camera is currently active\n   */\n  get isActive(): boolean {\n    return this.cameraStream !== null;\n  }\n\n  /**\n   * Get the video element (if camera is active)\n   */\n  get video(): HTMLVideoElement | null {\n    return this.cameraStream?.video ?? null;\n  }\n\n  /**\n   * Start camera stream\n   * @param options Camera configuration options\n   * @throws Error if camera access is denied or unavailable\n   */\n  async start(options: CameraOptions = {}): Promise<HTMLVideoElement> {\n    // Stop existing camera if running\n    this.stop();\n\n    const opts = { ...DEFAULT_CAMERA_OPTIONS, ...options };\n\n    if (!navigator.mediaDevices?.getUserMedia) {\n      throw new Error(\"Camera access is not supported in this browser\");\n    }\n\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: opts.facingMode,\n        width: { ideal: opts.width },\n        height: { ideal: opts.height },\n        frameRate: { ideal: opts.frameRate },\n      },\n    });\n\n    // Create video element for the stream\n    const video = document.createElement(\"video\");\n    video.srcObject = stream;\n    video.autoplay = true;\n    video.playsInline = true; // Required for iOS\n    video.muted = true; // Required for autoplay\n\n    // Hide the video element (we render to canvas)\n    video.style.display = \"none\";\n\n    // Wait for video to be ready\n    await new Promise<void>((resolve, reject) => {\n      video.onloadedmetadata = () => {\n        video\n          .play()\n          .then(() => resolve())\n          .catch(reject);\n      };\n      video.onerror = () => reject(new Error(\"Failed to load video stream\"));\n    });\n\n    // Append video element to DOM (required for some browsers)\n    document.body.appendChild(video);\n\n    this.cameraStream = { video, stream };\n\n    console.log(\"Camera started\");\n    return video;\n  }\n\n  /**\n   * Stop camera and clean up resources\n   */\n  stop(): void {\n    if (!this.cameraStream) {\n      return;\n    }\n\n    const { video, stream } = this.cameraStream;\n\n    // Stop all tracks\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n\n    // Clear video source\n    video.srcObject = null;\n\n    // Remove from DOM\n    video.remove();\n\n    this.cameraStream = null;\n    console.log(\"Camera stopped\");\n  }\n\n  /**\n   * Get current video frame dimensions\n   * @returns Dimensions or null if camera is not active or not ready\n   */\n  getFrameDimensions(): Dimensions | null {\n    if (!this.cameraStream || this.cameraStream.video.readyState < 2) {\n      return null;\n    }\n\n    return new Dimensions(\n      this.cameraStream.video.videoWidth,\n      this.cameraStream.video.videoHeight,\n    );\n  }\n\n  /**\n   * Register a video frame callback\n   * @param callback Function to call for each video frame\n   * @returns Callback ID for cancellation\n   */\n  requestVideoFrameCallback(callback: VideoFrameRequestCallback): number {\n    if (!this.cameraStream) {\n      throw new Error(\"Camera not active\");\n    }\n    return this.cameraStream.video.requestVideoFrameCallback(callback);\n  }\n\n  /**\n   * Cancel a video frame callback\n   * @param id Callback ID to cancel\n   */\n  cancelVideoFrameCallback(id: number): void {\n    if (this.cameraStream) {\n      this.cameraStream.video.cancelVideoFrameCallback(id);\n    }\n  }\n}\n"],"names":["CameraManager","options","opts","DEFAULT_CAMERA_OPTIONS","stream","video","resolve","reject","track","Dimensions","callback","id"],"mappings":";;AAqBO,MAAMA,EAAwC;AAAA,EAC3C,eAAoC;AAAA;AAAA;AAAA;AAAA,EAK5C,IAAI,WAAoB;AACtB,WAAO,KAAK,iBAAiB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAiC;AACnC,WAAO,KAAK,cAAc,SAAS;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,MAAMC,IAAyB,IAA+B;AAElE,SAAK,KAAA;AAEL,UAAMC,IAAO,EAAE,GAAGC,GAAwB,GAAGF,EAAA;AAE7C,QAAI,CAAC,UAAU,cAAc;AAC3B,YAAM,IAAI,MAAM,gDAAgD;AAGlE,UAAMG,IAAS,MAAM,UAAU,aAAa,aAAa;AAAA,MACvD,OAAO;AAAA,QACL,YAAYF,EAAK;AAAA,QACjB,OAAO,EAAE,OAAOA,EAAK,MAAA;AAAA,QACrB,QAAQ,EAAE,OAAOA,EAAK,OAAA;AAAA,QACtB,WAAW,EAAE,OAAOA,EAAK,UAAA;AAAA,MAAU;AAAA,IACrC,CACD,GAGKG,IAAQ,SAAS,cAAc,OAAO;AAC5C,WAAAA,EAAM,YAAYD,GAClBC,EAAM,WAAW,IACjBA,EAAM,cAAc,IACpBA,EAAM,QAAQ,IAGdA,EAAM,MAAM,UAAU,QAGtB,MAAM,IAAI,QAAc,CAACC,GAASC,MAAW;AAC3C,MAAAF,EAAM,mBAAmB,MAAM;AAC7B,QAAAA,EACG,KAAA,EACA,KAAK,MAAMC,GAAS,EACpB,MAAMC,CAAM;AAAA,MACjB,GACAF,EAAM,UAAU,MAAME,EAAO,IAAI,MAAM,6BAA6B,CAAC;AAAA,IACvE,CAAC,GAGD,SAAS,KAAK,YAAYF,CAAK,GAE/B,KAAK,eAAe,EAAE,OAAAA,GAAO,QAAAD,EAAA,GAE7B,QAAQ,IAAI,gBAAgB,GACrBC;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAa;AACX,QAAI,CAAC,KAAK;AACR;AAGF,UAAM,EAAE,OAAAA,GAAO,QAAAD,EAAA,IAAW,KAAK;AAG/B,eAAWI,KAASJ,EAAO;AACzB,MAAAI,EAAM,KAAA;AAIR,IAAAH,EAAM,YAAY,MAGlBA,EAAM,OAAA,GAEN,KAAK,eAAe,MACpB,QAAQ,IAAI,gBAAgB;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,qBAAwC;AACtC,WAAI,CAAC,KAAK,gBAAgB,KAAK,aAAa,MAAM,aAAa,IACtD,OAGF,IAAII;AAAA,MACT,KAAK,aAAa,MAAM;AAAA,MACxB,KAAK,aAAa,MAAM;AAAA,IAAA;AAAA,EAE5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,0BAA0BC,GAA6C;AACrE,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,mBAAmB;AAErC,WAAO,KAAK,aAAa,MAAM,0BAA0BA,CAAQ;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,yBAAyBC,GAAkB;AACzC,IAAI,KAAK,gBACP,KAAK,aAAa,MAAM,yBAAyBA,CAAE;AAAA,EAEvD;AACF;"}