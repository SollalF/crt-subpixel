{"version":3,"file":"CanvasManager.js","sources":["../../src/infrastructure/CanvasManager.ts"],"sourcesContent":["/**\n * Canvas Manager\n * Handles WebGPU canvas context configuration and sizing\n */\nimport { Dimensions } from \"../core/value-objects/Dimensions.js\";\nimport type { ICanvasManager } from \"../core/ports/ICanvasManager.js\";\nimport type { IGpuContext } from \"../core/ports/IGpuContext.js\";\n\n/**\n * Manages canvas configuration and WebGPU context\n */\nexport class CanvasManager implements ICanvasManager {\n  private canvas: HTMLCanvasElement | null = null;\n  private context: GPUCanvasContext | null = null;\n\n  /**\n   * Get the current canvas (if configured)\n   */\n  get currentCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /**\n   * Get the current WebGPU context (if configured)\n   */\n  get currentContext(): GPUCanvasContext | null {\n    return this.context;\n  }\n\n  /**\n   * Check if canvas is configured\n   */\n  get isConfigured(): boolean {\n    return this.canvas !== null && this.context !== null;\n  }\n\n  /**\n   * Configure canvas for WebGPU rendering\n   * @param canvas The canvas element to configure\n   * @param gpuContext The GPU context to use\n   * @throws Error if WebGPU context cannot be obtained\n   */\n  configure(canvas: HTMLCanvasElement, gpuContext: IGpuContext): void {\n    const context = canvas.getContext(\"webgpu\");\n    if (!context) {\n      throw new Error(\"Failed to get WebGPU context from canvas\");\n    }\n\n    this.canvas = canvas;\n    this.context = context;\n\n    context.configure({\n      device: gpuContext.device,\n      format: gpuContext.presentationFormat,\n      alphaMode: \"premultiplied\",\n    });\n  }\n\n  /**\n   * Set canvas size to match input dimensions with 3x expansion\n   * @param inputDimensions The input image/video dimensions\n   * @returns The resulting canvas dimensions\n   */\n  setSize(inputDimensions: Dimensions): Dimensions {\n    if (!this.canvas) {\n      throw new Error(\"Canvas not configured\");\n    }\n\n    const canvasWidth = Math.floor(inputDimensions.width * 3);\n    const canvasHeight = Math.floor(inputDimensions.height * 3);\n\n    this.canvas.width = canvasWidth;\n    this.canvas.height = canvasHeight;\n\n    return new Dimensions(canvasWidth, canvasHeight);\n  }\n\n  /**\n   * Update canvas aspect ratio based on input dimensions\n   */\n  setAspectRatio(inputDimensions: Dimensions): void {\n    if (!this.canvas) {\n      throw new Error(\"Canvas not configured\");\n    }\n\n    const aspectRatio = inputDimensions.width / inputDimensions.height;\n    this.canvas.style.aspectRatio = `${aspectRatio}`;\n  }\n\n  /**\n   * Get the current texture view for rendering\n   * @throws Error if canvas is not configured\n   */\n  getCurrentTextureView(): GPUTextureView {\n    if (!this.context) {\n      throw new Error(\"Canvas not configured\");\n    }\n    return this.context.getCurrentTexture().createView();\n  }\n\n  /**\n   * Export canvas content as a Blob\n   * @param type Image MIME type\n   * @param quality Image quality (for lossy formats)\n   */\n  async toBlob(\n    type: string = \"image/png\",\n    quality?: number,\n  ): Promise<Blob | null> {\n    if (!this.canvas) {\n      return null;\n    }\n\n    return new Promise((resolve) => {\n      this.canvas!.toBlob((blob) => resolve(blob), type, quality);\n    });\n  }\n\n  /**\n   * Start a synchronous blob export (returns promise but starts immediately)\n   * This is important for WebGPU where the backbuffer may be invalidated\n   */\n  toBlobSync(\n    type: string = \"image/png\",\n    quality?: number,\n  ): Promise<Blob | null> {\n    if (!this.canvas) {\n      return Promise.resolve(null);\n    }\n\n    return new Promise((resolve) => {\n      this.canvas!.toBlob((blob) => resolve(blob), type, quality);\n    });\n  }\n\n  /**\n   * Reset canvas manager state\n   */\n  reset(): void {\n    this.canvas = null;\n    this.context = null;\n  }\n}\n"],"names":["CanvasManager","canvas","gpuContext","context","inputDimensions","canvasWidth","canvasHeight","Dimensions","aspectRatio","type","quality","resolve","blob"],"mappings":";AAWO,MAAMA,EAAwC;AAAA,EAC3C,SAAmC;AAAA,EACnC,UAAmC;AAAA;AAAA;AAAA;AAAA,EAK3C,IAAI,gBAA0C;AAC5C,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,iBAA0C;AAC5C,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,eAAwB;AAC1B,WAAO,KAAK,WAAW,QAAQ,KAAK,YAAY;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAUC,GAA2BC,GAA+B;AAClE,UAAMC,IAAUF,EAAO,WAAW,QAAQ;AAC1C,QAAI,CAACE;AACH,YAAM,IAAI,MAAM,0CAA0C;AAG5D,SAAK,SAASF,GACd,KAAK,UAAUE,GAEfA,EAAQ,UAAU;AAAA,MAChB,QAAQD,EAAW;AAAA,MACnB,QAAQA,EAAW;AAAA,MACnB,WAAW;AAAA,IAAA,CACZ;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQE,GAAyC;AAC/C,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,uBAAuB;AAGzC,UAAMC,IAAc,KAAK,MAAMD,EAAgB,QAAQ,CAAC,GAClDE,IAAe,KAAK,MAAMF,EAAgB,SAAS,CAAC;AAE1D,gBAAK,OAAO,QAAQC,GACpB,KAAK,OAAO,SAASC,GAEd,IAAIC,EAAWF,GAAaC,CAAY;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,eAAeF,GAAmC;AAChD,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,uBAAuB;AAGzC,UAAMI,IAAcJ,EAAgB,QAAQA,EAAgB;AAC5D,SAAK,OAAO,MAAM,cAAc,GAAGI,CAAW;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,wBAAwC;AACtC,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,uBAAuB;AAEzC,WAAO,KAAK,QAAQ,kBAAA,EAAoB,WAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OACJC,IAAe,aACfC,GACsB;AACtB,WAAK,KAAK,SAIH,IAAI,QAAQ,CAACC,MAAY;AAC9B,WAAK,OAAQ,OAAO,CAACC,MAASD,EAAQC,CAAI,GAAGH,GAAMC,CAAO;AAAA,IAC5D,CAAC,IALQ;AAAA,EAMX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WACED,IAAe,aACfC,GACsB;AACtB,WAAK,KAAK,SAIH,IAAI,QAAQ,CAACC,MAAY;AAC9B,WAAK,OAAQ,OAAO,CAACC,MAASD,EAAQC,CAAI,GAAGH,GAAMC,CAAO;AAAA,IAC5D,CAAC,IALQ,QAAQ,QAAQ,IAAI;AAAA,EAM/B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,SAAS,MACd,KAAK,UAAU;AAAA,EACjB;AACF;"}