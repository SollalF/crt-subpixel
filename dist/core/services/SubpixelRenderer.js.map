{"version":3,"file":"SubpixelRenderer.js","sources":["../../../src/core/services/SubpixelRenderer.ts"],"sourcesContent":["/**\n * Subpixel Renderer Domain Service\n * Core business logic for calculating subpixel expansion dimensions\n * Pure domain logic with no infrastructure dependencies\n */\nimport { Dimensions } from \"../value-objects/Dimensions.js\";\nimport { PixelDensity } from \"../value-objects/PixelDensity.js\";\n\n/**\n * Domain service for subpixel rendering calculations\n */\nexport class SubpixelRenderer {\n  /**\n   * Calculate output dimensions for subpixel expansion\n   * Business rule: Each logical pixel expands to 3x3 physical pixels (RGB subpixels)\n   *\n   * @param input Input dimensions\n   * @param pixelDensity Pixel density (1 = normal, 2+ = chunkier)\n   * @returns Output dimensions after subpixel expansion\n   */\n  calculateOutputDimensions(\n    input: Dimensions,\n    pixelDensity: PixelDensity,\n  ): Dimensions {\n    const density = pixelDensity.getValue();\n    const logicalWidth = input.width / density;\n    const logicalHeight = input.height / density;\n\n    // Business rule: 3x expansion for RGB subpixels\n    return new Dimensions(\n      Math.floor(logicalWidth * 3),\n      Math.floor(logicalHeight * 3),\n    );\n  }\n\n  /**\n   * Calculate the pixel density that results in the closest output height to the target\n   *\n   * Formula: outputHeight = floor((inputHeight / density) * 3)\n   * To get outputHeight ≈ targetHeight: density ≈ inputHeight / (targetHeight / 3)\n   *\n   * @param input Input dimensions\n   * @param targetHeight Target output height in pixels (default: 480 for 480p)\n   * @returns Pixel density value that produces output closest to target height\n   */\n  calculatePixelDensityForTargetHeight(\n    input: Dimensions,\n    targetHeight: number = 480,\n  ): number {\n    // Calculate the ideal density: density = inputHeight / (targetHeight / 3)\n    const idealDensity = input.height / (targetHeight / 3);\n\n    // Verify which density (floor or ceil) gives us closer to target\n    const densityFloor = Math.max(1, Math.floor(idealDensity));\n    const densityCeil = Math.max(1, Math.ceil(idealDensity));\n\n    const outputFloor = Math.floor((input.height / densityFloor) * 3);\n    const outputCeil = Math.floor((input.height / densityCeil) * 3);\n\n    const diffFloor = Math.abs(outputFloor - targetHeight);\n    const diffCeil = Math.abs(outputCeil - targetHeight);\n\n    return diffFloor <= diffCeil ? densityFloor : densityCeil;\n  }\n}\n"],"names":["SubpixelRenderer","input","pixelDensity","density","logicalWidth","logicalHeight","Dimensions","targetHeight","idealDensity","densityFloor","densityCeil","outputFloor","outputCeil","diffFloor","diffCeil"],"mappings":";AAWO,MAAMA,EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS5B,0BACEC,GACAC,GACY;AACZ,UAAMC,IAAUD,EAAa,SAAA,GACvBE,IAAeH,EAAM,QAAQE,GAC7BE,IAAgBJ,EAAM,SAASE;AAGrC,WAAO,IAAIG;AAAA,MACT,KAAK,MAAMF,IAAe,CAAC;AAAA,MAC3B,KAAK,MAAMC,IAAgB,CAAC;AAAA,IAAA;AAAA,EAEhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,qCACEJ,GACAM,IAAuB,KACf;AAER,UAAMC,IAAeP,EAAM,UAAUM,IAAe,IAG9CE,IAAe,KAAK,IAAI,GAAG,KAAK,MAAMD,CAAY,CAAC,GACnDE,IAAc,KAAK,IAAI,GAAG,KAAK,KAAKF,CAAY,CAAC,GAEjDG,IAAc,KAAK,MAAOV,EAAM,SAASQ,IAAgB,CAAC,GAC1DG,IAAa,KAAK,MAAOX,EAAM,SAASS,IAAe,CAAC,GAExDG,IAAY,KAAK,IAAIF,IAAcJ,CAAY,GAC/CO,IAAW,KAAK,IAAIF,IAAaL,CAAY;AAEnD,WAAOM,KAAaC,IAAWL,IAAeC;AAAA,EAChD;AACF;"}