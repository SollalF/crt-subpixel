{"version":3,"file":"CrtSubpixelProcessor.js","sources":["../../src/presentation/CrtSubpixelProcessor.ts"],"sourcesContent":["/**\n * CRT Subpixel Processor\n *\n * A WebGPU-based library for expanding images into CRT-style subpixel patterns.\n * Each input pixel is expanded into a 3x3 block with vertical RGB stripes.\n *\n * Supports both static images and real-time camera input.\n * Both render directly to canvas and use canvas.toBlob() for export.\n *\n * Browser Support: Chrome/Edge desktop (requires secure context)\n */\nimport type { CameraOptions, Orientation } from \"../core/types.js\";\nimport { Orientation as OrientationVO } from \"../core/value-objects/Orientation.js\";\nimport type {\n  IGpuContext,\n  IRenderPipeline,\n  ICanvasManager,\n  ICameraManager,\n  ISettingsManager,\n} from \"../core/ports/index.js\";\nimport { GpuContext } from \"../infrastructure/GpuContext.js\";\nimport { RenderPipeline } from \"../infrastructure/RenderPipeline.js\";\nimport { CanvasManager } from \"../infrastructure/CanvasManager.js\";\nimport { CameraManager } from \"../infrastructure/CameraManager.js\";\nimport { SettingsManager } from \"../infrastructure/SettingsManager.js\";\nimport { ImageProcessor } from \"../use-cases/ImageProcessor.js\";\nimport { CameraProcessor } from \"../use-cases/CameraProcessor.js\";\n\n/**\n * Main processor class for CRT subpixel expansion\n *\n * Supports both static image processing and real-time camera input.\n * Both modes render directly to canvas and use canvas.toBlob() for export.\n *\n * @example\n * ```typescript\n * const processor = new CrtSubpixelProcessor();\n * await processor.init();\n *\n * // Static image processing\n * await processor.renderImage(canvas, imageBitmap);\n * const blob = await processor.exportImage(imageBitmap);\n *\n * // Camera mode\n * await processor.startCamera(canvas);\n * const frameBlob = await processor.exportCameraFrame();\n * processor.stopCamera();\n *\n * processor.destroy();\n * ```\n */\nexport class CrtSubpixelProcessor {\n  // Infrastructure components\n  private gpuContext: IGpuContext;\n  private pipeline: IRenderPipeline;\n  private canvasManager: ICanvasManager;\n  private cameraManager: ICameraManager;\n  private settingsManager: ISettingsManager;\n\n  // Use cases\n  private imageProcessor: ImageProcessor | null = null;\n  private cameraProcessor: CameraProcessor | null = null;\n\n  // Track current image for re-rendering\n  private currentImageBitmap: ImageBitmap | null = null;\n\n  constructor(\n    gpuContext?: IGpuContext,\n    pipeline?: IRenderPipeline,\n    canvasManager?: ICanvasManager,\n    cameraManager?: ICameraManager,\n    settingsManager?: ISettingsManager,\n  ) {\n    // Use provided dependencies or create default implementations\n    this.gpuContext = gpuContext ?? new GpuContext();\n    this.pipeline = pipeline ?? new RenderPipeline();\n    this.canvasManager = canvasManager ?? new CanvasManager();\n    this.cameraManager = cameraManager ?? new CameraManager();\n    this.settingsManager = settingsManager ?? new SettingsManager();\n  }\n\n  /**\n   * Check if processor is initialized\n   */\n  get initialized(): boolean {\n    return this.gpuContext.initialized;\n  }\n\n  /**\n   * Initialize GPU device and compile shaders\n   * Must be called before processing any images or starting camera\n   *\n   * @throws Error if GPU is not supported or initialization fails\n   */\n  async init(): Promise<void> {\n    if (this.initialized) {\n      console.log(\"Processor already initialized\");\n      return;\n    }\n\n    // Initialize GPU context\n    await this.gpuContext.init();\n\n    // Connect settings to GPU\n    this.settingsManager.connect(this.gpuContext);\n\n    // Create pipeline\n    this.pipeline.create(this.gpuContext);\n\n    // Create use cases\n    this.imageProcessor = new ImageProcessor(\n      this.gpuContext,\n      this.pipeline,\n      this.canvasManager,\n      this.settingsManager,\n    );\n\n    this.cameraProcessor = new CameraProcessor(\n      this.gpuContext,\n      this.pipeline,\n      this.canvasManager,\n      this.cameraManager,\n      this.settingsManager,\n    );\n\n    console.log(\"CrtSubpixelProcessor initialized\");\n  }\n\n  // ============================================\n  // Image Rendering\n  // ============================================\n\n  /**\n   * Render an image with CRT subpixel effect directly to canvas\n   *\n   * @param canvas Target canvas element for rendering\n   * @param input Image to process (ImageBitmap - JPEG/PNG formats)\n   * @throws Error if not initialized or rendering fails\n   */\n  async renderImage(\n    canvas: HTMLCanvasElement,\n    input: ImageBitmap,\n  ): Promise<void> {\n    if (!this.imageProcessor) {\n      throw new Error(\n        \"Processor not initialized. Call init() before rendering images.\",\n      );\n    }\n\n    // Stop camera if running (switching to image mode)\n    if (this.isCameraRunning()) {\n      this.stopCamera();\n    }\n\n    // Store for potential re-render (e.g., orientation change)\n    this.currentImageBitmap = input;\n\n    await this.imageProcessor.render(canvas, input);\n  }\n\n  /**\n   * Export an image by re-running the render pipeline and capturing the result\n   * This is needed because WebGPU clears the canvas after each frame is presented\n   *\n   * @param input The ImageBitmap to render and export\n   * @param type Image MIME type (e.g., 'image/png', 'image/jpeg')\n   * @param quality For lossy formats like JPEG, quality from 0 to 1\n   * @returns Promise resolving to the image Blob, or null if export fails\n   */\n  async exportImage(\n    input: ImageBitmap,\n    type: string = \"image/png\",\n    quality?: number,\n  ): Promise<Blob | null> {\n    if (!this.imageProcessor) {\n      console.warn(\"Processor not initialized\");\n      return null;\n    }\n\n    return this.imageProcessor.export(input, { type, quality });\n  }\n\n  // ============================================\n  // Camera Processing\n  // ============================================\n\n  /**\n   * Start camera and begin rendering CRT effect to canvas in real-time\n   *\n   * @param canvas Target canvas element for rendering\n   * @param options Camera options (resolution, facing mode, etc.)\n   * @throws Error if not initialized or camera access fails\n   */\n  async startCamera(\n    canvas: HTMLCanvasElement,\n    options?: CameraOptions,\n  ): Promise<void> {\n    if (!this.cameraProcessor) {\n      throw new Error(\"Processor not initialized. Call init() first.\");\n    }\n\n    await this.cameraProcessor.start(canvas, options);\n  }\n\n  /**\n   * Stop camera and clean up camera resources\n   */\n  stopCamera(): void {\n    this.cameraProcessor?.stop();\n  }\n\n  /**\n   * Check if camera is currently running\n   */\n  isCameraRunning(): boolean {\n    return this.cameraProcessor?.isRunning ?? false;\n  }\n\n  /**\n   * Export the current camera frame as an image blob\n   *\n   * Only works in camera mode - captures after the next render.\n   * For image mode, use exportImage() instead.\n   *\n   * @param type Image MIME type (e.g., 'image/png', 'image/jpeg')\n   * @param quality For lossy formats like JPEG, quality from 0 to 1\n   * @returns Promise resolving to the image Blob, or null if camera is not running\n   */\n  async exportCameraFrame(\n    type: string = \"image/png\",\n    quality?: number,\n  ): Promise<Blob | null> {\n    if (!this.cameraProcessor) {\n      console.warn(\"Processor not initialized\");\n      return null;\n    }\n\n    return this.cameraProcessor.exportFrame({ type, quality });\n  }\n\n  // ============================================\n  // Settings\n  // ============================================\n\n  /**\n   * Set the RGB stripe orientation\n   *\n   * @param mode 'columns' for vertical stripes, 'rows' for horizontal stripes, or Orientation value object\n   */\n  setOrientation(mode: Orientation | OrientationVO): void {\n    // Convert string to value object if needed (for backward compatibility)\n    const orientation =\n      typeof mode === \"string\" ? OrientationVO.from(mode) : mode;\n    this.settingsManager.orientation = orientation;\n\n    // Re-render current image if in image mode\n    if (\n      !this.isCameraRunning() &&\n      this.currentImageBitmap &&\n      this.canvasManager.currentCanvas\n    ) {\n      this.imageProcessor?.render(\n        this.canvasManager.currentCanvas,\n        this.currentImageBitmap,\n      );\n    }\n  }\n\n  /**\n   * Get the current RGB stripe orientation\n   */\n  getOrientation(): OrientationVO {\n    return this.settingsManager.orientation;\n  }\n\n  /**\n   * Set the pixel density for chunky pixel effect\n   *\n   * @param density Number of input pixels to treat as one logical pixel (1 = normal, 2+ = chunkier)\n   */\n  setPixelDensity(density: number): void {\n    this.settingsManager.pixelDensity = density;\n\n    // Notify camera processor to update canvas size\n    this.cameraProcessor?.onPixelDensityChanged();\n\n    // Re-render current image if in image mode\n    if (\n      !this.isCameraRunning() &&\n      this.currentImageBitmap &&\n      this.canvasManager.currentCanvas\n    ) {\n      this.imageProcessor?.render(\n        this.canvasManager.currentCanvas,\n        this.currentImageBitmap,\n      );\n    }\n  }\n\n  /**\n   * Get the current pixel density\n   */\n  getPixelDensity(): number {\n    return this.settingsManager.pixelDensity;\n  }\n\n  /**\n   * Set interlaced rendering mode\n   *\n   * @param enabled true for interlaced (renders only every other scanline), false for progressive\n   */\n  setInterlaced(enabled: boolean): void {\n    this.settingsManager.interlaced = enabled;\n\n    // Re-render current image if in image mode\n    if (\n      !this.isCameraRunning() &&\n      this.currentImageBitmap &&\n      this.canvasManager.currentCanvas\n    ) {\n      this.imageProcessor?.render(\n        this.canvasManager.currentCanvas,\n        this.currentImageBitmap,\n      );\n    }\n  }\n\n  /**\n   * Get the current interlaced mode\n   */\n  getInterlaced(): boolean {\n    return this.settingsManager.interlaced;\n  }\n\n  /**\n   * Set field selection for interlaced rendering\n   *\n   * @param field 'odd' for odd scanlines, 'even' for even scanlines\n   */\n  setField(field: \"odd\" | \"even\"): void {\n    this.settingsManager.field = field;\n\n    // Re-render current image if in image mode\n    if (\n      !this.isCameraRunning() &&\n      this.currentImageBitmap &&\n      this.canvasManager.currentCanvas\n    ) {\n      this.imageProcessor?.render(\n        this.canvasManager.currentCanvas,\n        this.currentImageBitmap,\n      );\n    }\n  }\n\n  /**\n   * Get the current field selection\n   */\n  getField(): \"odd\" | \"even\" {\n    return this.settingsManager.field;\n  }\n\n  // ============================================\n  // Cleanup\n  // ============================================\n\n  /**\n   * Clean up all GPU resources\n   * Call this when done with the processor to free GPU memory\n   */\n  destroy(): void {\n    // Stop camera if running\n    this.stopCamera();\n\n    // Disconnect settings\n    this.settingsManager.disconnect();\n\n    // Clean up pipeline\n    this.pipeline.destroy();\n\n    // Reset canvas manager\n    this.canvasManager.reset();\n\n    // Clean up GPU resources\n    this.gpuContext.destroy();\n\n    // Clear use cases\n    this.imageProcessor = null;\n    this.cameraProcessor = null;\n    this.currentImageBitmap = null;\n  }\n}\n"],"names":["CrtSubpixelProcessor","gpuContext","pipeline","canvasManager","cameraManager","settingsManager","GpuContext","RenderPipeline","CanvasManager","CameraManager","SettingsManager","ImageProcessor","CameraProcessor","canvas","input","type","quality","options","mode","orientation","OrientationVO","density","enabled","field"],"mappings":"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"}