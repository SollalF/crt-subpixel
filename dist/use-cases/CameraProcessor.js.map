{"version":3,"file":"CameraProcessor.js","sources":["../../src/use-cases/CameraProcessor.ts"],"sourcesContent":["/**\n * Camera Processor Use Case\n * Orchestrates real-time camera processing with CRT subpixel effect\n */\nimport type { CameraOptions, ExportOptions } from \"../core/types.js\";\nimport type {\n  IGpuContext,\n  IRenderPipeline,\n  ICanvasManager,\n  ICameraManager,\n  ISettingsManager,\n} from \"../core/ports/index.js\";\nimport { Dimensions, PixelDensity } from \"../core/value-objects/index.js\";\nimport { SubpixelRenderer } from \"../core/services/index.js\";\n\n/**\n * Pending export request state\n */\ninterface PendingExport {\n  resolve: (blob: Blob | null) => void;\n  type: string;\n  quality: number | undefined;\n}\n\n/**\n * Handles real-time camera processing\n */\nexport class CameraProcessor {\n  private videoFrameCallbackId: number | undefined;\n  private lastFrameSize: Dimensions | null = null;\n  private pendingExport: PendingExport | null = null;\n  private frameCount: number = 0;\n  private readonly subpixelRenderer: SubpixelRenderer;\n\n  constructor(\n    private gpuContext: IGpuContext,\n    private pipeline: IRenderPipeline,\n    private canvasManager: ICanvasManager,\n    private cameraManager: ICameraManager,\n    private settingsManager: ISettingsManager,\n  ) {\n    this.subpixelRenderer = new SubpixelRenderer();\n  }\n\n  /**\n   * Check if camera processing is active\n   */\n  get isRunning(): boolean {\n    return this.cameraManager.isActive;\n  }\n\n  /**\n   * Update canvas size for new frame dimensions\n   */\n  private updateCanvasSize(frameWidth: number, frameHeight: number): void {\n    // Create domain objects\n    const inputDimensions = new Dimensions(frameWidth, frameHeight);\n    const pixelDensity = PixelDensity.from(this.settingsManager.pixelDensity);\n\n    // Set canvas size (3x input)\n    this.canvasManager.setSize(inputDimensions);\n\n    // Calculate output dimensions using domain service\n    const outputDimensions = this.subpixelRenderer.calculateOutputDimensions(\n      inputDimensions,\n      pixelDensity,\n    );\n\n    // Update GPU dimensions\n    this.gpuContext.writeOutputDimensions(outputDimensions);\n\n    // Update aspect ratio\n    this.canvasManager.setAspectRatio(inputDimensions);\n\n    const canvas = this.canvasManager.currentCanvas;\n    console.log(\n      `Canvas size: ${canvas?.width}x${canvas?.height}, rendering ${outputDimensions.width}x${outputDimensions.height} pixels`,\n    );\n  }\n\n  /**\n   * Process a video frame callback\n   */\n  private processVideoFrame = (\n    _now: number,\n    metadata: VideoFrameCallbackMetadata,\n  ): void => {\n    if (\n      !this.gpuContext.initialized ||\n      !this.pipeline.isCreated ||\n      !this.canvasManager.isConfigured ||\n      !this.cameraManager.isActive\n    ) {\n      return;\n    }\n\n    const video = this.cameraManager.video;\n    if (!video || video.readyState < 2) {\n      // Video not ready, schedule next frame\n      this.scheduleNextFrame();\n      return;\n    }\n\n    const frameWidth = metadata.width;\n    const frameHeight = metadata.height;\n\n    // Create domain object for input dimensions\n    const inputDimensions = new Dimensions(frameWidth, frameHeight);\n\n    // Update input dimensions\n    this.gpuContext.writeInputDimensions(inputDimensions);\n\n    // Update canvas if frame size changed\n    if (!this.lastFrameSize || !this.lastFrameSize.equals(inputDimensions)) {\n      this.lastFrameSize = inputDimensions;\n      this.updateCanvasSize(frameWidth, frameHeight);\n    }\n\n    // Auto-alternate fields for interlaced rendering\n    if (this.settingsManager.interlaced) {\n      // Toggle field each frame: odd (frame 0, 2, 4...) or even (frame 1, 3, 5...)\n      const isOddField = this.frameCount % 2 === 0;\n      this.settingsManager.field = isOddField ? \"odd\" : \"even\";\n    }\n\n    // Render frame\n    this.pipeline.render(video, this.canvasManager.getCurrentTextureView());\n\n    // Increment frame count for field alternation\n    this.frameCount++;\n\n    // Handle pending export\n    if (this.pendingExport) {\n      const { resolve, type, quality } = this.pendingExport;\n      this.pendingExport = null;\n      this.canvasManager.toBlobSync(type, quality).then(resolve);\n    }\n\n    // Schedule next frame\n    this.scheduleNextFrame();\n  };\n\n  /**\n   * Schedule the next frame callback\n   */\n  private scheduleNextFrame(): void {\n    if (this.cameraManager.isActive) {\n      this.videoFrameCallbackId = this.cameraManager.requestVideoFrameCallback(\n        this.processVideoFrame,\n      );\n    }\n  }\n\n  /**\n   * Start camera and begin rendering to canvas\n   * @param canvas Target canvas for rendering\n   * @param options Camera configuration options\n   */\n  async start(\n    canvas: HTMLCanvasElement,\n    options?: CameraOptions,\n  ): Promise<void> {\n    if (!this.gpuContext.initialized || !this.pipeline.isCreated) {\n      throw new Error(\"Processor not initialized\");\n    }\n\n    // Stop existing camera if running\n    this.stop();\n\n    // Configure canvas\n    this.canvasManager.configure(canvas, this.gpuContext);\n\n    // Start camera\n    await this.cameraManager.start(options);\n\n    // Start render loop\n    this.scheduleNextFrame();\n\n    console.log(\"Camera processing started\");\n  }\n\n  /**\n   * Stop camera processing\n   */\n  stop(): void {\n    // Cancel pending frame callback\n    if (this.videoFrameCallbackId !== undefined) {\n      this.cameraManager.cancelVideoFrameCallback(this.videoFrameCallbackId);\n      this.videoFrameCallbackId = undefined;\n    }\n\n    // Stop camera\n    this.cameraManager.stop();\n\n    // Reset state\n    this.lastFrameSize = null;\n    this.frameCount = 0;\n\n    // Resolve pending export with null\n    if (this.pendingExport) {\n      this.pendingExport.resolve(null);\n      this.pendingExport = null;\n    }\n\n    console.log(\"Camera processing stopped\");\n  }\n\n  /**\n   * Export the current camera frame as a Blob\n   * @param options Export options (type, quality)\n   * @returns Promise resolving to Blob or null if camera not running\n   */\n  async exportFrame(options: ExportOptions = {}): Promise<Blob | null> {\n    if (!this.canvasManager.isConfigured) {\n      console.warn(\"No canvas configured\");\n      return null;\n    }\n\n    if (!this.isRunning) {\n      console.warn(\"Camera is not running\");\n      return null;\n    }\n\n    const type = options.type ?? \"image/png\";\n    const quality = options.quality;\n\n    return new Promise((resolve) => {\n      this.pendingExport = { resolve, type, quality };\n    });\n  }\n\n  /**\n   * Notify that pixel density changed (update canvas if running)\n   */\n  onPixelDensityChanged(): void {\n    if (this.isRunning && this.lastFrameSize) {\n      this.updateCanvasSize(\n        this.lastFrameSize.width,\n        this.lastFrameSize.height,\n      );\n    }\n  }\n}\n"],"names":["CameraProcessor","gpuContext","pipeline","canvasManager","cameraManager","settingsManager","SubpixelRenderer","frameWidth","frameHeight","inputDimensions","Dimensions","pixelDensity","PixelDensity","outputDimensions","canvas","_now","metadata","video","isOddField","resolve","type","quality","options"],"mappings":"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"}